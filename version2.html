<!DOCTYPE html>
<head>
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <script src='threejs/three.js'></script>
  <script src='loaders/OBJLoader.js'></script>
  <script src='loaders/MTLLoader.js'></script>
  <script src='https://rawcdn.githack.com/mrdoob/three.js/r86/examples/js/loaders/GLTFLoader.js'></script>
  
  <script src="jsartoolkit5/artoolkit.min.js"></script>
  <script src="jsartoolkit5/artoolkit.api.js"></script>
	
  <script src="threex/threex-artoolkitsource.js"></script>
  <script src="threex/threex-artoolkitcontext.js"></script>
  <script src="threex/threex-arbasecontrols.js"></script>
  <script src="threex/threex-armarkercontrols.js"></script>

</head>
<body style="margin : 0px; overflow: hidden;">
   <video id="video" autoplay loop crossOrigin="anonymous" webkit-playsinline style="display:none">
	<source src="video.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
   </video>
  <script>
    var scene, camera, renderer, clock, deltaTime, totalTime;

    var arToolkitSource, arToolkitContext;
	
	var markerRoot1, markerRoot2;

    var mesh1,mesh2;
	
	initialize();
	render();
	animate();

	function initialize()
	{
		scene = new THREE.Scene();

		let ambientLight = new THREE.AmbientLight( 0xcccccc, 1.0 );
		scene.add( ambientLight );
		
		//const fov = 45;
		//const aspect = 2;  
		//const near = 0.1;
		//const far = 100;			
		camera = new THREE.Camera();
		scene.add(camera);

		renderer = new THREE.WebGLRenderer({
			antialias : true,
			alpha: true,
			logarithmicDepthBuffer:true,
			preserveDrawingBuffer:true
		});
		renderer.setClearColor(new THREE.Color('lightgrey'), 0)
		renderer.setSize( 640, 480 );
		renderer.domElement.style.position = 'absolute'
		renderer.domElement.style.top = '0px'
		renderer.domElement.style.left = '0px'
		document.body.appendChild( renderer.domElement );
		
		//obitControls = new OrbitControls(camera, renderer.domElement);	

		clock = new THREE.Clock();
		deltaTime = 0;
		totalTime = 0;
		
		////////////////////////////////////////////////////////////
		// setup arToolkitSource
		////////////////////////////////////////////////////////////

		arToolkitSource = new THREEx.ArToolkitSource({
			sourceType : 'webcam',
		});

		function onResize()
		{
			arToolkitSource.onResize()	
			arToolkitSource.copySizeTo(renderer.domElement)	
			if ( arToolkitContext.arController !== null )
			{
				arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)	
			}	
		}

		arToolkitSource.init(function onReady(){
			onResize()
		});
		
		// handle resize event
		window.addEventListener('resize', function(){
			onResize()
		});
		
		////////////////////////////////////////////////////////////
		// setup arToolkitContext
		////////////////////////////////////////////////////////////	

		// create atToolkitContext
		arToolkitContext = new THREEx.ArToolkitContext({
			cameraParametersUrl: 'camera_para.dat',
			detectionMode: 'mono'
		});
		
		// copy projection matrix to camera when initialization complete
		arToolkitContext.init( function onCompleted(){
			camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
		});

		////////////////////////////////////////////////////////////
		// setup markerRoots
		////////////////////////////////////////////////////////////

		// build markerControls
		markerRoot1 = new THREE.Group();
		scene.add(markerRoot1);
		markerRoot2 = new THREE.Group();
		scene.add(markerRoot2);
		let markerControls1 = new THREEx.ArMarkerControls(arToolkitContext, markerRoot1, {
			type: 'pattern', patternUrl: "pattern-marker.patt",
		})

		let geometry1 = new THREE.PlaneBufferGeometry(1,1, 4,4);
		let loader = new THREE.TextureLoader();
		
		let material1 = new THREE.MeshBasicMaterial( { color: 0x0000ff, opacity: 0.5 } );
		mesh1 = new THREE.Mesh( geometry1, material1 );
		mesh1.rotation.x = -Math.PI/2;
		mesh2 = new THREE.Mesh( geometry1, material1 );
		mesh2.rotation.x = -Math.PI/2;
		markerRoot1.add( mesh1 );
		markerRoot2.add( mesh2 );
		
		function onProgress(xhr) { console.log( (xhr.loaded / xhr.total * 100) + '% loaded' ); }
		function onError(xhr) { console.log( 'An error happened' ); }
		
		new THREE.MTLLoader()
		.setPath( 'models/' )
		.load( 'fish-2.mtl', function ( materials ) {
			materials.preload();
			new THREE.OBJLoader()
				.setMaterials( materials )
				.setPath( 'models/' )
				.load( 'fish-2.obj', function ( group ) {
					mesh0 = group.children[0];
					mesh0.material.side = THREE.DoubleSide;
					mesh0.position.y = 2;
					mesh0.scale.set(1,1,1);
					markerRoot1.add(mesh0);
				}, onProgress, onError );
		});
		
		let geometry2 = new THREE.PlaneBufferGeometry(2,2, 4,4);
		let video = document.getElementById( 'video' );
		let texture = new THREE.VideoTexture( video );
		texture.minFilter = THREE.LinearFilter;
		texture.magFilter = THREE.LinearFilter;
		texture.format = THREE.RGBFormat;
		let material2 = new THREE.MeshBasicMaterial( { map: texture } );
		
		mesh2 = new THREE.Mesh( geometry2, material2 );
		mesh2.rotation.x = -Math.PI/2;
		
		markerRoot2.add( mesh2 );
	}


	function update()
	{
		// update artoolkit on every frame
		if ( arToolkitSource.ready !== false )
			arToolkitContext.update( arToolkitSource.domElement );
	}


	function render()
	{
	    //obitControls.update();
		renderer.render( scene, camera );
	}


	function animate()
	{
		requestAnimationFrame(animate);
		deltaTime = clock.getDelta();
		totalTime += deltaTime;
		update();
		render();
	}

  </script>
  
 
   
</body>
</html>